{
  "sections": {
    "command-reference": {
      "title": "Command Reference",
      "content": "This document provides a reference for all commands available in the `grove-context` (`cx`) tool.",
      "subsections": [
        {
          "title": "Core Commands",
          "content": "Commands for generating, inspecting, and editing the primary context files.\n\n---\n\n### `cx generate`\n\n**Usage**: `cx generate [--xml]`\n\n**Description**:\nReads file patterns from the active rules file (`.grove/rules` by default), resolves them to a list of files, and concatenates their contents into the `.grove/context` (hot context) and `.grove/cached-context` (cold context) files.\n\n**Arguments**: None.\n\n**Flags**:\n- `--xml` (bool, default: `true`): Use XML-style delimiters for context files.\n\n**Examples**:\n\n**Related Commands**: `cx update`, `cx show`, `cx edit`\n\n---\n\n### `cx list`\n\n**Usage**: `cx list`\n\n**Description**:\nPrints the absolute paths of all files included in the hot context, based on the active rules file. The list is deduplicated and sorted.\n\n**Arguments**: None.\n\n**Flags**: None.\n\n**Examples**:\n\n**Related Commands**: `cx show`, `cx listcache`\n\n---\n\n### `cx show`\n\n**Usage**: `cx show`\n\n**Description**:\nOutputs the entire content of the generated `.grove/context` file to standard output. This is useful for piping the context directly to other tools or LLMs.\n\n**Arguments**: None.\n\n**Flags**: None.\n\n**Examples**:\n\n**Related Commands**: `cx list`, `cx generate`\n\n---\n\n### `cx edit`\n\n**Usage**: `cx edit`\n\n**Description**:\nOpens the active `.grove/rules` file in the default editor specified by the `$EDITOR` environment variable. If the file does not exist, it will be created with boilerplate content.\n\n**Arguments**: None.\n\n**Flags**: None.\n\n**Examples**:\n\n**Related Commands**: `cx rules`, `cx reset`",
          "code_blocks": [
            "# Generate context using active rules\ncx generate",
            "# List all files in the current hot context\ncx list\n\n# Pipe the list to another command\ncx list | wc -l",
            "# Print the full context to the terminal\ncx show\n\n# Pipe the context to an LLM\ncx show | llm -m gemini-2.5-pro \"Analyze this code\"",
            "# Open the rules file for editing\ncx edit"
          ]
        },
        {
          "title": "Git Integration",
          "content": "Commands for creating context based on Git repository history.\n\n---\n\n### `cx from-git`\n\n**Usage**: `cx from-git [flags]`\n\n**Description**:\nGenerates context rules by including files that have changed in the Git repository based on specified criteria. It overwrites the active `.grove/rules` file with the list of changed files.\n\n**Arguments**: None.\n\n**Flags**:\n- `--since \u003cdate|commit\u003e`: Include files changed since a specific date, time, or commit hash.\n- `--branch \u003crange\u003e`: Include files changed in a branch or commit range (e.g., `main..HEAD`).\n- `--staged`: Include only files that are currently staged for commit.\n- `--commits \u003cn\u003e`: Include files from the last `n` commits.\n\n**Examples**:\n\n**Related Commands**: `cx diff`\n\n---\n\n### `cx diff`\n\n**Usage**: `cx diff [ruleset-name]`\n\n**Description**:\nCompares the files included by the currently active rules against a named rule set (snapshot). It shows which files were added or removed, and the change in total token count and file size.\n\n**Arguments**:\n- `ruleset-name` (optional): The name of the rule set to compare against. If omitted, compares against an empty context.\n\n**Flags**: None.\n\n**Examples**:\n\n**Related Commands**: `cx rules`, `cx from-git`",
          "code_blocks": [
            "# Include files changed in the last 24 hours\ncx from-git --since \"24 hours ago\"\n\n# Include files changed on the current branch compared to 'main'\ncx from-git --branch main\n\n# Include all staged files\ncx from-git --staged",
            "# Compare current context to the 'dev-no-tests' rule set\ncx diff dev-no-tests\n\n# See what the current context adds compared to an empty context\ncx diff"
          ]
        },
        {
          "title": "Snapshots (Rule Sets)",
          "content": "Commands for managing named context configurations, referred to as rule sets or snapshots. These are stored in `.cx/` (version-controlled) and `.cx.work/` (local-only) directories.\n\n---\n\n### `cx rules list`\n\n**Usage**: `cx rules list [--for-project \u003calias\u003e] [--json]`\n\n**Description**:\nLists all available rule sets found in the `.cx/` and `.cx.work/` directories. Indicates the currently active rule set.\n\n**Arguments**: None.\n\n**Flags**:\n- `--for-project \u003calias\u003e`: List rule sets for a different project specified by its alias.\n- `--json`: Output the list of rule sets in JSON format.\n\n**Examples**:\n\n**Related Commands**: `cx rules set`, `cx rules save`\n\n---\n\n### `cx rules save`\n\n**Usage**: `cx rules save \u003cname\u003e [--work]`\n\n**Description**:\nSaves the currently active rules (from `.grove/rules` or another set) to a new named file in the `.cx/` directory.\n\n**Arguments**:\n- `name` (required): The name to give the new rule set.\n\n**Flags**:\n- `-w`, `--work`: Save the rule set to the `.cx.work/` directory for temporary, untracked sets.\n\n**Examples**:\n\n**Related Commands**: `cx rules load`\n\n---\n\n### `cx rules load`\n\n**Usage**: `cx rules load \u003cname\u003e`\n\n**Description**:\nCopies a named rule set from `.cx/` or `.cx.work/` to `.grove/rules`, creating a modifiable working copy. This makes `.grove/rules` the active context source.\n\n**Arguments**:\n- `name` (required): The name of the rule set to load.\n\n**Flags**: None.\n\n**Examples**:\n\n**Related Commands**: `cx rules save`, `cx rules set`",
          "code_blocks": [
            "# List all rule sets for the current project\ncx rules list",
            "# Save the current rules as a version-controlled set named 'feature-x-api'\ncx rules save feature-x-api\n\n# Save the current rules as a temporary, local-only set\ncx rules save my-temp-rules --work",
            "# Create a local, editable copy of the 'default' rule set\ncx rules load default"
          ]
        },
        {
          "title": "Interactive Tools",
          "content": "Commands for interactive context management and analysis.\n\n---\n\n### `cx view`\n\n**Usage**: `cx view [--page \u003cpage\u003e]`\n\n**Description**:\nLaunches a multi-tab interactive terminal UI for visualizing and managing context composition.\n\n**Tabs**:\n- **TREE**: A file tree showing which files are included (hot/cold), excluded, or ignored.\n- **RULES**: A view of the active rules file, allowing for quick edits.\n- **STATS**: A breakdown of context by file type and a list of the largest files by token count.\n- **LIST**: A detailed, flat list of all files considered, with options for exclusion.\n\n**Arguments**: None.\n\n**Flags**:\n- `-p`, `--page \u003cpage\u003e` (string, default: `tree`): The page to open on startup (tree, rules, stats, list).\n\n**Examples**:\n\n**Related Commands**: `cx stats`, `cx rules`\n\n---\n\n### `cx stats`\n\n**Usage**: `cx stats [rules-file] [--top \u003cn\u003e] [--per-line]`\n\n**Description**:\nProvides a detailed command-line analysis of the context composition, including language breakdown, largest files, and token distribution.\n\n**Arguments**:\n- `rules-file` (optional): Path to a specific rules file to analyze. If omitted, uses the active rules file.\n\n**Flags**:\n- `--top \u003cn\u003e` (int, default: `5`): The number of largest files to display.\n- `--per-line`: Provide token and file count statistics for each individual line in the rules file (output as JSON).\n\n**Examples**:\n\n**Related Commands**: `cx view`",
          "code_blocks": [
            "# Launch the interactive view on the default TREE page\ncx view\n\n# Start directly on the STATS page\ncx view --page stats",
            "# Get stats for the currently active context\ncx stats\n\n# Get stats for a different rule set and show the top 10 largest files\ncx stats .cx/docs.rules --top 10"
          ]
        },
        {
          "title": "Repository Management",
          "content": "Commands for managing external Git repositories used as context sources.\n\n---\n\n### `cx repo`\n\n**Usage**: `cx repo \u003csubcommand\u003e`\n\n**Description**:\nProvides subcommands for managing external Git repositories that are cloned and used as sources for context rules (e.g., via `git@github.com:owner/repo` patterns).\n\n**Subcommands**:\n- `list`: List all tracked repositories and their status.\n- `sync`: Fetch updates for all tracked repositories.\n- `audit`: Perform an interactive security audit on a repository.\n\n**Examples**:\n\n**Related Commands**: `cx rules`",
          "code_blocks": [
            "# List all repositories defined in the rules files\ncx repo list\n\n# Fetch updates for all repositories\ncx repo sync"
          ]
        },
        {
          "title": "Workspace Management",
          "content": "Commands for interacting with the Grove workspace model.\n\n---\n\n### `cx workspace list`\n\n**Usage**: `cx workspace list [--json]`\n\n**Description**:\nLists all discovered workspaces, including projects, ecosystems, and their worktrees. For each entry, it provides a unique, resolvable alias (identifier).\n\n**Arguments**: None.\n\n**Flags**:\n- `--json`: Output the workspace list in JSON format.\n\n**Examples**:\n\n**Related Commands**: `cx resolve`\n\n---\n\n### `cx resolve`\n\n**Usage**: `cx resolve \u003crule\u003e`\n\n**Description**:\nResolves a single rule pattern, such as an alias (`@a:my-repo/path`), to its corresponding list of absolute file paths.\n\n**Arguments**:\n- `rule` (required): The rule pattern to resolve.\n\n**Flags**:\n- `--rules-file \u003cpath\u003e`: Path to a rules file for context-aware resolution.\n- `--line-number \u003cn\u003e`: Line number within the rules file for context-aware resolution.\n\n**Examples**:\n\n**Related Commands**: `cx workspace list`, `cx edit`",
          "code_blocks": [
            "# List all workspaces and their aliases\ncx workspace list",
            "# Resolve a simple alias\ncx resolve \"@a:grove-core\"\n\n# Resolve an alias with a path pattern\ncx resolve \"@a:grove-ecosystem:grove-flow/cmd\""
          ]
        },
        {
          "title": "Validation \u0026 Maintenance",
          "content": "Commands for maintaining the integrity and state of context rules.\n\n---\n\n### `cx validate`\n\n**Usage**: `cx validate`\n\n**Description**:\nChecks all files in the current context for integrity. It verifies that all files exist, are accessible, and reports any duplicates.\n\n**Arguments**: None.\n\n**Flags**: None.\n\n**Examples**:\n\n**Related Commands**: `cx fix`\n\n---\n\n### `cx fix`\n\n**Usage**: `cx fix`\n\n**Description**:\nThis command is deprecated. Context is now resolved dynamically from rules, so there is no file list to fix. To fix issues, edit the rules file directly.\n\n**Arguments**: None.\n\n**Flags**: None.\n\n**Related Commands**: `cx edit`, `cx validate`\n\n---\n\n### `cx reset`\n\n**Usage**: `cx reset [--force]`\n\n**Description**:\nResets the active `.grove/rules` file to the project's default, as defined by `context.default_rules_path` in `grove.yml`. If no default is configured, a boilerplate rules file is created.\n\n**Arguments**: None.\n\n**Flags**:\n- `-f`, `--force`: Reset the rules file without a confirmation prompt.\n\n**Examples**:\n\n**Related Commands**: `cx edit`, `cx rules load`\n\n---\n\n### `cx setrules`\n\n**Usage**: `cx setrules \u003cpath-to-rules-file\u003e`\n\n**Description**:\nCopies an external rules file to `.grove/rules`, making it the active set of rules for the project.\n\n**Arguments**:\n- `path-to-rules-file` (required): The path to the rules file to use.\n\n**Flags**: None.\n\n**Examples**:\n\n**Related Commands**: `cx rules load`, `cx rules set`",
          "code_blocks": [
            "# Validate the files in the current context\ncx validate",
            "# Reset the rules file to its default state\ncx reset",
            "# Set the active rules from a file in a shared directory\ncx setrules ../../shared/rules/go-api.rules"
          ]
        },
        {
          "title": "Cache Management",
          "content": "Commands for inspecting cached context.\n\n---\n\n### `cx listcache`\n\n**Usage**: `cx listcache`\n\n**Description**:\nLists the absolute paths of all files included in the cold (cached) context, based on the patterns found after the `---` separator in the active rules file.\n\n**Arguments**: None.\n\n**Flags**: None.\n\n**Examples**:\n\n**Related Commands**: `cx list`",
          "code_blocks": [
            "# List all files that are part of the cached context\ncx listcache"
          ]
        },
        {
          "title": "Utility",
          "content": "Miscellaneous utility commands.\n\n---\n\n### `cx version`\n\n**Usage**: `cx version [--json]`\n\n**Description**:\nPrints the version, commit, and build date for the `cx` binary.\n\n**Arguments**: None.\n\n**Flags**:\n- `--json`: Output version information in JSON format.\n\n**Examples**:",
          "code_blocks": [
            "# Show version information\ncx version"
          ]
        }
      ]
    },
    "context-generation": {
      "title": "Context Generation",
      "content": "The `grove-context` tool, aliased as `cx`, provides a mechanism for generating a context file from a set of rules. This document describes the pipeline from rule definition to final output and its integration with other Grove tools.",
      "subsections": [
        {
          "title": "1. Generation Pipeline Overview",
          "content": "The context generation process follows a clear transformation:\n\n1.  **Rules File (`.grove/rules`)**: The process starts with a rules file containing patterns that specify which files to include or exclude. The active rules file can be `.grove/rules` or a named set from `.cx/` or `.cx.work/`.\n2.  **File List Resolution**: The tool resolves these patterns into a definitive list of file paths. This step respects `.gitignore` files, handles aliases (`@a:`), and resolves rule set imports (`::`).\n3.  **Context Output (`.grove/context`)**: The contents of the resolved files are concatenated into a single XML-formatted file, `.grove/context`, which is then used by LLM-based tools.\n\n### Automatic and Manual Generation\n\n-   **Automatic**: Tools like `grove-gemini` and `grove-flow` automatically trigger context generation before making an LLM request to ensure the context is up-to-date.\n-   **Manual**: You can manually trigger this process using the `cx generate` command. This is useful for inspecting the final output or when using the context file with external tools."
        },
        {
          "title": "2. The `cx list` Command",
          "content": "The `cx list` command displays the absolute paths of all files included in the context based on the current rules. Its primary purpose is to allow verification of the context before it is used.\n\n**Example Usage:**\n\n\nThe command outputs a simple, newline-separated list of file paths, suitable for piping to other commands. For detailed metrics like token counts and file sizes, use the `cx stats` command.",
          "code_blocks": [
            "# List all files currently in the context\ncx list"
          ]
        },
        {
          "title": "3. The .grove/context Output File",
          "content": "The final output of the generation process is the `.grove/context` file. This file is not meant to be edited directly and should be added to `.gitignore`.\n\n### Format Specification\n\nThe file uses a simple XML structure to wrap the content of each included file. This format provides clear delimiters and metadata for LLMs to parse.\n\n\n-   Each file's content is enclosed in a `\u003cfile\u003e` tag.\n-   The `path` attribute contains the file path relative to the project root.",
          "code_blocks": [
            "\u003cfile path=\"src/main.go\"\u003e\n// file content here\n\u003c/file\u003e\n\n\u003cfile path=\"pkg/config.yaml\"\u003e\n# yaml content here\n\u003c/file\u003e"
          ]
        },
        {
          "title": "4. Context Statistics with `cx stats`",
          "content": "The `cx stats` command provides a detailed analysis of the context's composition, helping you monitor its size and complexity.\n\n**Features:**\n\n-   **Summary Metrics**: Total number of files, total token count, and total file size.\n-   **Language Distribution**: A breakdown of the context by programming language, showing token and file counts for each.\n-   **Largest Files**: A list of the largest files by token count, helping to identify major contributors to context size.\n\n**Example Usage:**",
          "code_blocks": [
            "# Show statistics for the current context\ncx stats"
          ]
        },
        {
          "title": "5. File Handling and Security",
          "content": "`grove-context` includes mechanisms to handle different file types and enforce security boundaries to prevent accidental inclusion of unintended files.\n\n-   **Binary File Exclusion**: Binary files (e.g., images, executables, archives) are detected and excluded by default to keep the context focused on text-based content.\n-   **Security Boundaries**: The tool restricts file inclusion to specific, allowed root directories. By default, these are:\n    1.  Discovered Grove workspaces (projects, ecosystems, and their worktrees).\n    2.  The `~/.grove/` directory.\n    3.  Notebook root directories defined in `grove.yml`.\n    4.  Paths explicitly defined in `context.allowed_paths` in `grove.yml`.\n\n    This boundary prevents rules like `../**/*` from including arbitrary files from the filesystem (e.g., `/etc/passwd`). Any attempt to include a file outside these boundaries is ignored, and a warning is printed.\n\n### Best Practices for Security\n\n-   Always review the output of `cx list` before using the generated context, especially before sharing it.\n-   Add sensitive files and directories (e.g., `secrets/`, `.env*`) to your exclusion patterns in `.grove/rules`.\n-   Keep the generated `.grove/context` file in your project's `.gitignore`."
        },
        {
          "title": "6. Integration Points",
          "content": "The context generation pipeline is a core component used by several other Grove tools.\n\n-   **grove-gemini**: When making a request with `gemapi request`, context is automatically generated. Hot context files are passed as dynamic files, while cold context is managed via Gemini's caching API.\n-   **grove-flow**: Before executing `oneshot` or `chat` jobs, `grove-flow` regenerates the context to ensure it is current. Jobs can specify their own `rules_file` in their frontmatter for job-specific context. Context is scoped to the job's working directory or worktree.\n-   **grove-nvim**: The Neovim plugin provides real-time feedback while editing `.grove/rules` files. It displays virtual text next to each rule showing the number of files and tokens it contributes, and allows interactive preview of the files matched by a rule."
        }
      ]
    },
    "context-tui": {
      "title": "Context TUI",
      "content": "The `cx view` command launches a tabbed terminal user interface (TUI) for inspecting and managing context. It provides several views to analyze which files are included based on the active rules, see token consumption, and interactively modify the context.",
      "subsections": [
        {
          "title": "Overview",
          "content": "The TUI is organized into four main tabs:\n\n-   **TREE**: A hierarchical file browser showing the project structure.\n-   **RULES**: A viewer for the active rules file.\n-   **STATS**: An analytics view of context composition by file type and size.\n-   **LIST**: A flat list of all files included in the context.\n\nThe interface provides real-time token counts and visual indicators for file status, and allows for interactive rule editing and context switching."
        },
        {
          "title": "Tab System",
          "content": "### TREE Tab\n\nThe TREE tab displays a hierarchical view of the project's file system.\n\n-   **Navigation**: Directories can be expanded and collapsed using arrow keys.\n-   **Visual Indicators**:\n    -   `‚úì`: File or directory is included in the hot or cold context.\n    -   `üö´`: File or directory is explicitly excluded by a rule.\n    -   `(CWD)`: Marks the current working directory.\n-   **Token Counts**: Estimated token counts are shown inline for each directory and included file, allowing for quick identification of high-token areas.\n\n### RULES Tab\n\nThe RULES tab displays the content of the active rules file.\n\n-   **Path Display**: Shows the path to the currently active rules file (e.g., `.grove/rules` or a named set from `.cx/`).\n-   **Content Viewer**: Displays the full content of the rules file with syntax highlighting for comments and directives.\n-   **Editing**: Pressing `e` opens the active rules file in your default editor (`$EDITOR`).\n\n### STATS Tab\n\nThe STATS tab provides an analytical breakdown of the context composition. It is split into two panels:\n\n-   **File Type Distribution**: Lists file types (e.g., `.go`, `.md`) sorted by their total token contribution, showing percentages, token counts, and file counts for each.\n-   **Largest Files**: Lists the individual files that contribute the most tokens to the context.\n\nThis view helps identify which file types or specific files are consuming the most context space.\n\n### LIST Tab\n\nThe LIST tab shows a flat, sortable list of every file included in the context.\n\n-   **Detailed View**: Each entry displays the file's full path and individual token count.\n-   **Sorting**: The list can be sorted alphabetically or by token count.\n-   **Exclusion**: Individual files can be excluded from the context directly from this view by pressing `x`."
        },
        {
          "title": "Keyboard Shortcuts",
          "content": "### Global Navigation\n\n-   `tab` / `shift+tab`: Switch between TREE, RULES, STATS, and LIST tabs.\n-   `‚Üë`/`‚Üì` or `j`/`k`: Navigate up/down within the current view's list or tree.\n-   `?`: Toggle the help display.\n-   `q` / `ctrl+c`: Quit the TUI.\n\n### TREE Tab\n\n-   `‚Üí` or `l`: Expand the selected directory.\n-   `‚Üê` or `h`: Collapse the selected directory.\n-   `enter` or `space`: Toggle expand/collapse for the selected directory.\n-   `za`: Toggle fold at cursor.\n-   `zo`/`zc`: Open/close fold at cursor.\n-   `zR`/`zM`: Open/close all folds.\n-   `t`: Toggle sort order (alphabetical vs. token count).\n\n### RULES Tab\n\n-   `e`: Edit the active rules file in `$EDITOR`.\n\n### STATS Tab\n\n-   `s` or `‚Üê`/`‚Üí`: Switch focus between the \"File Types\" and \"Largest Files\" lists.\n\n### LIST Tab\n\n-   `x`: Exclude the selected file from the context.\n-   `t`: Toggle sort order (alphabetical vs. token count).\n\n### Context Management Actions\n\n-   `e` (Most Tabs): Edit the active rules file in `$EDITOR`.\n-   `s` (Most Tabs): Open a selector to switch to a different named rule set from `.cx/`.\n-   `r` (Most Tabs): Refresh the context and reload all views."
        },
        {
          "title": "Workflow Examples",
          "content": "### Example 1: Understanding Your Context\n\n1.  Run `cx view` to open the TUI.\n2.  Start in the **TREE** tab to see a hierarchical overview of included directories (marked with `‚úì`).\n3.  Press `tab` to navigate to the **STATS** tab. Review the \"File Types\" panel to see which languages or file types contribute most to the context size.\n4.  Press `tab` again to go to the **LIST** tab for a complete, flat list of every included file.\n5.  Finally, switch to the **RULES** tab to see the patterns in the active rules file that produced this context.\n\n### Example 2: Optimizing Context Size\n\n1.  Run `cx view` and navigate to the **STATS** tab.\n2.  Identify a file type that is consuming a high percentage of tokens (e.g., `.go` files at 98.5%).\n3.  Note the largest individual files in the \"Largest Files\" panel.\n4.  Switch to the **LIST** tab, navigate to a large, unnecessary file, and press `x` to exclude it. The file will be immediately removed from the list.\n5.  Alternatively, press `e` to open the rules file and add a broader exclusion pattern (e.g., `!**/*_test.go`).\n6.  After saving the rules file, press `r` in the TUI to refresh and see the updated statistics.\n\n### Example 3: Switching Contexts\n\n1.  Run `cx view`.\n2.  Press `s` to open the rule set selector, which lists all available sets from `.cx/` and `.cx.work/`.\n3.  Use the arrow keys to select a different rule set (e.g., \"backend-only\") and press `enter`.\n4.  The context regenerates, and all tabs update to reflect the new set of included files.\n5.  Verify the change in the **TREE** tab by confirming that only backend-related directories are now included.\n\n### Example 4: Visual Context Review\n\n-   Use the **TREE** tab for a quick visual assessment. Included directories are marked with `‚úì` and show their total token contribution, such as `pkg ‚úì (29.5k)`.\n-   Immediately spot directories that are excluded by rules, marked with `üö´`, such as `tests üö´`.\n-   To understand why a directory is included or excluded, navigate to the **RULES** tab to review the patterns in effect."
        }
      ]
    },
    "editor-integration": {
      "title": "Editor Integration",
      "content": "Editor integration for `grove-context` provides real-time feedback and streamlined workflows for managing context rules directly within your code editor. The primary integration is the `grove-nvim` plugin for Neovim, which offers a comprehensive set of features for interacting with the `cx` tool.\n\n### Overview of Editor Integration\n\nEditor integration connects the `grove-context` command-line tool (`cx`) to your development environment. This allows you to:\n\n*   Receive immediate feedback on the impact of your context rules as you edit them.\n*   Verify which files are matched by a given pattern.\n*   Navigate directly from an aliased path in your rules file to the corresponding file or directory.\n*   Invoke interactive `cx` commands without leaving the editor.\n\n### Neovim Plugin (`grove-nvim`)\n\n`grove-nvim` is a Neovim plugin that provides deep integration with the `grove-context` ecosystem.\n\n#### Installation and Setup\n\nThe plugin can be installed using any standard Neovim package manager. Once installed, it automatically detects `groverules` files and activates its features.\n\n#### Features\n\n**1. Filetype Detection and Syntax Highlighting**\n\nThe plugin automatically detects files named `.grove/rules`, `.grovectx`, or with a `.rules` extension and sets the `groverules` filetype. This enables:\n*   **Syntax Highlighting**: Distinguishes comments, patterns, directives (`@a:`, `@view:`, `---`), and exclusions (`!`).\n*   **Commenting**: Sets the comment string to `#`, allowing standard comment toggling commands (e.g., `gc`) to work correctly.\n\n**2. Real-time Virtual Text**\n\nWhen editing a `groverules` file, the plugin displays inline virtual text at the end of each rule line, providing immediate feedback. This information is generated by running `cx stats --per-line` in the background.\n\nThe virtual text includes:\n*   **Token and File Counts**: Shows the approximate token count and the number of files matched by a rule (e.g., `~1.2k tokens (5 files)`).\n*   **Exclusion Info**: For exclusion rules, it shows the number of files and tokens that were removed from the context.\n*   **No Match Warnings**: Displays a warning (`‚ö† no matches`) if a rule does not match any files.\n*   **Git Repository Status**: For rules that include external Git repositories, it displays the pinned version, resolved commit hash, and audit status.\n\n**3. Interactive Rule Preview**\n\nThe `\u003cleader\u003ef?` keybinding invokes an interactive file picker that shows all files matched by the rule under the cursor. This is powered by the `cx resolve` command.\n\n*   **Usage**: Place the cursor on a rule line and press `\u003cleader\u003ef?`.\n*   **Functionality**: A floating window appears listing all resolved file paths. This works for simple glob patterns, aliases (`@a:workspace/path`), and ruleset imports (`@a:project::ruleset`).\n*   **Adding Files**: You can select one or more files from the picker to add them as explicit, individual rules to your `groverules` file. This is useful for refining a broad pattern into a specific list of files.\n\n**4. Smart Navigation (`gf`)**\n\nThe standard Neovim `gf` (go-to-file) command is enhanced to understand Grove aliases. When the cursor is on a path containing an alias like `@a:my-ecosystem:my-repo/src/main.go`, pressing `gf` will resolve the alias and open the correct file, even if it's in a different project outside the current working directory.\n\nIf a pattern matches multiple files, `gf` will open a picker to let you choose which file to open.\n\n**5. Interactive Commands**\n\nThe plugin provides commands to run interactive `cx` TUIs within a floating terminal window in Neovim:\n\n*   `:GroveContextView`: Opens the `cx view` TUI, providing a full-screen, interactive tree view of the current context.\n*   `:GroveRules`: Opens the `cx rules` TUI, allowing you to switch between named rule sets.\n*   `:GroveEditContext`: Opens the active rules file for editing. This is particularly useful for quickly accessing job-specific rules defined in `grove-flow` plans.\n\n**6. Alias Resolution**\n\nThe plugin bridges the gap between workspace-relative aliases and their absolute file paths on disk.\n*   `neogrove internal resolve-aliases`: A command within the plugin's binary (`neogrove`) reads file paths from stdin and uses the `grove-core` workspace discovery mechanism to convert them into canonical `@a:` aliases. This is used to display concise, portable paths in features like the marks window.\n*   `cx workspace list --json`: The plugin uses this command to get a real-time list of all discovered workspaces, which is essential for providing completion suggestions for aliases.\n\n### Workflow Example\n\nA typical workflow when using `grove-nvim`:\n\n1.  **Open Rules File**: Open `.grove/rules` in Neovim. Virtual text appears immediately, showing stats for each rule.\n2.  **Add a New Rule**: You add a new pattern, e.g., `pkg/**/*.go`. The virtual text updates after a short delay, showing how many files and tokens this rule adds.\n3.  **Preview the Rule**: With the cursor on `pkg/**/*.go`, you press `\u003cleader\u003ef?`. A file picker appears, listing all the `.go` files in the `pkg` directory.\n4.  **Refine the Rule**: You notice an unwanted file in the preview. You add an exclusion rule below it: `!pkg/unwanted/file.go`. The virtual text on the first rule updates to reflect the exclusion.\n5.  **Navigate to a File**: You see an aliased rule like `@a:grove-core/pkg/workspace/types.go`. You place your cursor on it and press `gf`. The `types.go` file from the `grove-core` project opens in a new buffer.\n6.  **Check Full Context**: You run `:GroveContextView` to see the complete, hierarchical tree of your context, verifying that all expected files are included and excluded correctly.\n\n### Configuration\n\n`grove-nvim` comes with a set of default keybindings, which can be customized in your Neovim configuration.\n\n**Default Keybindings:**\n*   `\u003cleader\u003ef?`: Preview files for the rule under the cursor.\n*   `\u003cleader\u003efe`: Edit the active context rules file.\n*   `\u003cleader\u003efv`: Open the `cx view` TUI.\n*   `gf`: Go to the file or alias under the cursor.\n\n### Other Editors (VS Code, etc.)\n\nWhile Neovim has the most comprehensive integration, `grove-context` can be used with any editor through the command line. The `cx edit` command provides a basic integration point by opening the active rules file in the editor defined by your `$EDITOR` environment variable. This allows for a simpler workflow where you can quickly open, edit, and then run `cx generate` or `cx stats` in a separate terminal."
    },
    "examples": {
      "title": "Examples",
      "content": "Here are five practical examples for using Grove Context (`cx`), following the provided documentation style guide.\n\n### Example 1: Quick Start - Pattern-Based Context\n\nGrove Context (`cx`) generates a context file (`.grove/context`) by including files that match patterns defined in a rules file. By default, it reads rules from `.grove/rules`.\n\n1.  **Create a rules file**: Start by creating a `.grove/rules` file. You can do this manually or by running `cx edit`. In Neovim, the keybinding `\u003cleader\u003efe` opens the active rules file.\n\n    ```\n    # .grove/rules\n    \n    # Include all Go files\n    *.go\n    \n    # Exclude test files\n    !*_test.go\n    \n    # Include all Markdown files in the docs/ directory\n    docs/**/*.md\n    ```\n\n2.  **Verify the context**: Run `cx list` to see a list of absolute file paths included in the context.\n\n    ```bash\n    $ cx list\n    /path/to/project/main.go\n    /path/to/project/internal/server.go\n    /path/to/project/docs/guide.md\n    ```\n\n3.  **Analyze context statistics**: Use `cx stats` to see a breakdown of the context by file type, token count, and size. This helps identify which files contribute most to the context size. In Neovim, statistics for each rule are displayed as virtual text next to the rule itself, updating in real-time as you edit.\n\n4.  **Explore visually with the TUI**: Run `cx view` to launch an interactive terminal interface.\n    *   **TREE**: A file explorer view showing which files are included (hot/cold), excluded, or omitted.\n    *   **RULES**: Displays the content of the active rules file. Press `e` to edit it.\n    *   **STATS**: A detailed breakdown of token and file counts by language.\n    *   **LIST**: A flat list of all included files, sortable by name or token count.\n\nThe tool automatically excludes binary files, so there is no need to add patterns like `!*.bin` or `!*.png`.\n\n### Example 2: Reusable Rule Sets for Context Switching\n\nFor projects with multiple components (e.g., backend, frontend, docs), you can create named rule sets in the `.cx/` directory to switch contexts quickly.\n\n1.  **Create named rule sets**: Define different contexts in separate files within the `.cx/` directory.\n\n    ```\n    # .cx/backend.rules\n    # Context for backend development\n    pkg/api/**/*.go\n    !pkg/api/**/*_test.go\n    cmd/server/*.go\n    ```\n\n    ```\n    # .cx/frontend.rules\n    # Context for frontend development\n    ui/src/**/*.ts\n    ui/src/**/*.tsx\n    ```\n\n2.  **Switch between contexts**: Use `cx rules set \u003cname\u003e` to activate a rule set. The active set is stored in project state (`.grove/state`) and used by all subsequent `cx` commands.\n\n    ```bash\n    # Work on the backend\n    $ cx rules set backend\n    Active context rules set to 'backend'\n    \n    # Work on the frontend\n    $ cx rules set frontend\n    Active context rules set to 'frontend'\n    ```\n\n3.  **Import rule sets**: You can import rule sets from other projects using the `@a:project::ruleset` syntax. This allows for composition of context from multiple sources.\n\n    ```\n    # .cx/full-stack.rules\n    \n    # Import the backend rules from the 'api-server' project\n    @a:api-server::backend\n    \n    # Also include local frontend files\n    ui/src/**/*.ts\n    ```\n\nFor temporary or personal rule sets that should not be committed to version control, use the `.cx.work/` directory instead of `.cx/`.\n\n### Example 3: Working with Aliases and Workspaces\n\nAliases are shortcuts that resolve to the absolute path of a Grove workspace (a project or ecosystem). This is useful in multi-repository setups.\n\n1.  **List available workspaces**: Run `cx workspace list` (or `grove ws list`) to see all discovered projects and their unique identifiers, which function as aliases.\n\n2.  **Use aliases in rules**: Reference projects directly without needing relative paths. Grove Context provides context-aware resolution, prioritizing sibling projects within the same ecosystem.\n\n    ```\n    # .grove/rules\n    \n    # Include the main package from the grove-nvim project\n    @a:grove-nvim/main.go\n    \n    # Include all Go files from the grove-core project within the grove-ecosystem\n    @a:grove-ecosystem:grove-core/**/*.go\n    \n    # Include files from a specific worktree of a project\n    @a:grove-flow:my-feature-branch/pkg/orchestration/*.go\n    ```\n\n3.  **Preview alias matches**: In Neovim, place your cursor over a rule containing an alias and press `\u003cleader\u003ef?` to open a file picker showing all files matched by that rule. This allows for quick verification of complex patterns.\n\n### Example 4: Grove-Flow Integration\n\nGrove Flow, the job orchestrator, uses `grove-context` to automatically prepare the context for each job it runs.\n\n1.  **Per-job context**: You can specify a custom rules file for a particular job in its frontmatter. This is useful for tasks that require a very specific subset of the codebase.\n\n    ```yaml\n    # 02-refactor-api.md\n    ---\n    id: refactor-api-job\n    title: \"Refactor API\"\n    type: agent\n    rules_file: .cx/backend.rules # This job will use the backend-only context\n    ---\n    Refactor the API endpoints in `pkg/api/` to use the new service layer.\n    ```\n\n2.  **Automatic context generation**: Before executing a job, `grove-flow` regenerates the context based on the active or job-specific rules. This ensures the LLM always has the most up-to-date view of the relevant files.\n\n3.  **Interactive context creation**: If `grove-flow` runs a job in a worktree where no `.grove/rules` file exists, it will prompt you interactively to create one, edit it, or proceed without context. This prevents jobs from running with an empty context by mistake.\n\n### Example 5: Managing Complex Projects\n\n`cx` provides tools for understanding and refining context in large or unfamiliar codebases.\n\n1.  **Load a base rule set**: Start by loading a shared rule set as your working copy with `cx rules load \u003cname\u003e`. This copies the file to `.grove/rules` so your changes don't affect the original.\n\n2.  **Use the TUI for refinement**: Run `cx view` to analyze the context.\n    *   Navigate the **TREE** tab to see the file structure and identify directories with high token counts.\n    *   Switch to the **STATS** tab to see a breakdown by language and identify the largest files.\n    *   Open the **RULES** tab to see the active rules and press `e` to edit them directly.\n    *   Use the **LIST** tab to find a specific file and press `x` to add an exclusion rule for it.\n    *   Press `s` to open an interactive selector to switch to a different named rule set.\n\n3.  **Include local or external repositories**:\n    *   **Local**: Add relative paths to your rules file (e.g., `../shared-library/**`).\n    *   **External**: For third-party repositories, first run `cx repo audit \u003cgit-url\u003e` to perform a security review. Once audited, you can add the Git URL directly to your rules file (e.g., `git@github.com:user/repo.git`), and `cx` will use the locally cloned, audited version.\n\n4.  **Use Git for context**: Quickly generate context for a code review by using Git history.\n    *   `cx from-git --staged`: Includes all currently staged files.\n    *   `cx from-git --commits 1`: Includes all files changed in the last commit.\n\n5.  **Reset to defaults**: If your rules file becomes too complex, run `cx reset` to revert it to the default specified in your project's `grove.yml` or to a basic boilerplate."
    },
    "experimental": {
      "title": "Experimental Features",
      "content": "A command-line tool for managing file-based context for LLM prompts.",
      "subsections": [
        {
          "title": "Core Mechanism",
          "content": "The `cx` tool operates on a plain text \"rules file\" (by default `.grove/rules`) that defines which files to include in a context. It resolves patterns in this file to a list of file paths.\n\n- **Rules File**: A text file containing patterns (globs, file paths, aliases) to include or exclude files.\n- **Context Generation**: The `cx generate` command reads the rules and concatenates the content of all matched files into a single output file (`.grove/context`).\n- **Interactive View**: The `cx view` command provides a terminal interface to visualize which files are included, excluded, or ignored."
        },
        {
          "title": "Usage",
          "content": "| Command                 | Description                                                               |\n| ----------------------- | ------------------------------------------------------------------------- |\n| `cx generate`           | Generates the `.grove/context` file from the active rules.                |\n| `cx view`               | Starts an interactive TUI to visualize the context tree.                  |\n| `cx stats`              | Shows statistics about the current context (token counts, file types).    |\n| `cx list`               | Prints the list of absolute file paths included in the context.           |\n| `cx rules \u003csubcommand\u003e` | Manages named rule sets (list, set, save, load).                          |\n| `cx from-git`           | Populates rules from files changed in git history.                        |\n| `cx from-cmd`           | Populates rules from the stdout of a shell command.                       |\n| `cx repo \u003csubcommand\u003e`  | Manages external git repositories used in the context.                    |\n| `cx diff [ruleset]`     | Compares the current context with a named rule set.                       |\n| `cx resolve [rule]`     | Prints the list of files a single rule resolves to.                       |"
        },
        {
          "title": "The Rules File (`.grove/rules`)",
          "content": "The rules file is a line-by-line definition of the context.\n\n### Basic Patterns\n\n-   **Inclusion**: Standard glob patterns (e.g., `*.go`, `src/**/*.js`).\n-   **Exclusion**: Patterns prefixed with `!` (e.g., `!*_test.go`).\n-   **Comments**: Lines starting with `#` are ignored.\n-   **Order**: The last matching pattern for a file determines its inclusion or exclusion.\n\n### Hot and Cold Context\n\nA `---` separator splits the rules file into two sections:\n1.  **Hot Context (above `---`)**: Files that change frequently.\n2.  **Cold Context (below `---`)**: Files that are stable (e.g., library code, dependencies).\n\nThis separation is used by other tools (like `grove-gemini`) to potentially cache the cold context.\n\n### Workspace Aliases (`@a:`)\n\nWorkspace aliases refer to other projects discovered by Grove, allowing for cross-repository context. The alias format is based on the project's identifier.\n\n-   **Standalone Project**: `@a:project-name/path/to/file`\n-   **Ecosystem Sub-Project**: `@a:ecosystem-name:project-name/path/to/file`\n-   **Project Worktree**: `@a:project-name:worktree-name/path/to/file`\n\n**Example:**\n\n### Git Repositories\n\nExternal git repositories can be included by adding their URL to the rules file. The `cx repo sync` command is used to clone or update these repositories to a local cache.\n\n**Example:**\n\n### Inheriting Rules (`@default:`)\n\nThe `@default:` directive inherits the default rule set from another project. It reads the `context.default_rules_path` from the target project's `grove.yml` and includes its rules.\n\n**Example:**\n\n### Dynamic Rules\n\n-   `@cmd: \u003ccommand\u003e`: Executes a shell command and includes each line of its output as a file path.\n-   `cx from-git`: A command to generate rules from files in recent commits or branches.\n-   `cx from-cmd`: A command to generate rules from a command's output.",
          "code_blocks": [
            "# Include a directory from the grove-core project within the grove-ecosystem\n@a:grove-ecosystem:grove-core/pkg/workspace/**",
            "# Include a specific version of an external repository\nhttps://github.com/some-org/some-repo@v1.2.3\n\n# Include the main branch\nhttps://github.com/another-org/another-repo",
            "# Inherit all rules from the project located at ../my-library\n@default: ../my-library"
          ]
        },
        {
          "title": "Interactive View (`cx view`)",
          "content": "`cx view` launches a terminal-based file tree that visualizes the current context.\n\n-   **Color Coding**: Files are colored based on their status (hot, cold, excluded).\n-   **Interactivity**:\n    -   `h`: Toggle inclusion in hot context.\n    -   `c`: Toggle inclusion in cold context.\n    -   `x`: Toggle exclusion.\n-   **Live Updates**: Changes made in the TUI are written back to the `.grove/rules` file."
        },
        {
          "title": "Named Rule Sets (`.cx/`)",
          "content": "`grove-context` supports storing multiple named rule sets. This allows for switching between different context definitions for various tasks.\n\n-   `.cx/`: Directory for version-controlled rule sets (e.g., `.cx/api.rules`).\n-   `.cx.work/`: Directory for local, temporary rule sets (gitignored by default).\n\n**Commands:**\n-   `cx rules list`: List all available rule sets.\n-   `cx rules set \u003cname\u003e`: Set a named rule set as the active, read-only source.\n-   `cx rules load \u003cname\u003e`: Copy a named rule set to `.grove/rules` to use as a modifiable working copy.\n-   `cx rules save \u003cname\u003e`: Save the current `.grove/rules` content to a new named rule set."
        },
        {
          "title": "Experimental Features",
          "content": "### Hot/Cold Context Caching (‚ö†Ô∏è EXPERIMENTAL - USE WITH CAUTION)\n\n-   **WARNING**: This feature is experimental and can lead to high API costs if misconfigured.\n-   The cold context (files defined below `---`) can be cached by `grove-gemini` to reduce token costs on repeated requests.\n-   **Caching Directives**:\n    -   `@enable-cache`: Opt-in to enable caching for this rules file.\n    -   `@freeze-cache`: Use the existing cache even if files have changed.\n    -   `@no-expire`: Prevent the cache from expiring based on TTL.\n    -   `@expire-time \u003cduration\u003e`: Set a custom TTL for the cache (e.g., `24h`).\n-   **Risks**:\n    -   Improper TTL settings can lead to excessive cache regeneration costs.\n    -   Stale cached context can be used if files change without the cache being updated.\n    -   Debugging can be difficult if the cache is out of sync.\n-   **Recommendation**: Use this feature only if you have a thorough understanding of LLM API caching mechanisms and associated costs. Monitor API usage and billing closely.\n\n### MCP Integration for Automatic Context Management\n\n-   The `grove-mcp` tool enables agents to manage context by calling `cx` commands via a defined protocol.\n-   This allows an LLM to dynamically adjust its own file-based context during a task.\n-   This is an experimental feature for developing autonomous agents."
        },
        {
          "title": "Common Use Cases and Limitations",
          "content": "### Use Cases\n-   Defining a consistent set of files to be included in an LLM prompt.\n-   Switching between different \"views\" of a codebase (e.g., a \"full-context\" vs. a \"docs-only\" rule set).\n-   Interactively building a context for a specific task using `cx view`.\n-   Auditing which files are being sent to an LLM.\n\n### Limitations\n-   `cx` is a file preprocessor; it does not directly interact with any LLM APIs. Other tools like `grove-gemini` consume its output.\n-   The tool relies on filesystem operations and `git` commands. Performance may vary on very large projects.\n-   It is not a language-specific dependency management tool. It operates on file paths and patterns."
        }
      ]
    },
    "external-repositories": {
      "title": "External Repositories",
      "content": "This document describes how `grove-context` (`cx`) manages context from external Git repositories and other local projects.\n\n### Including External Sources\n\n`grove-context` can include files from sources outside the current project's working directory. This is useful for monorepos, shared libraries, or including third-party code for analysis. There are two primary methods for including external sources: direct path references and managed Git repositories.\n\n#### 1. Local Path References\n\nYou can include files from other local projects using relative paths in your `.grove/rules` file. This is common in monorepo setups where projects are in sibling directories.\n\n**Example:**\n\nAll paths are sandboxed. By default, `cx` will only resolve patterns within discovered Grove workspaces. You can add specific directories to this sandbox using the `context.allowed_paths` key in your `grove.yml`.\n\n#### 2. Managed Git Repositories\n\nYou can reference remote Git repositories directly in your rules file. `cx` will automatically clone and manage these repositories in a centralized location (`~/.grove/repos/`).\n\n**Example:**\n\nWhen a rule containing a Git URL is processed, `cx` performs the following actions:\n1.  Parses the URL to identify the repository and an optional version (tag, branch, or commit hash).\n2.  Adds the repository to a central manifest located at `~/.grove/repos.json`.\n3.  Clones the repository into `~/.grove/repos/\u003cdomain\u003e/\u003cowner\u003e/\u003crepo\u003e` if it doesn't already exist.\n4.  Fetches updates and checks out the specified version. If no version is specified, it uses the repository's default branch.\n5.  Replaces the URL in the rule with the local path to the cloned repository and resolves the file patterns.\n\n### Cross-Project References with Aliases\n\nFor more complex monorepos or ecosystems, `grove-context` uses an alias system for robust, location-independent references between projects.\n\n#### The `@default` Directive\n\nThe `@default` directive imports the default rule set from another Grove project. The target project must have a `context.default_rules_path` defined in its `grove.yml`.\n\n**Example:**\nSuppose you have a `shared-lib` project with default rules defined in its `grove.yml`:\n\n\nYou can import these rules into `my-app` as follows:\n\n\n#### The `@alias` (`@a:`) Directive\n\nThe `@alias` directive (short form `@a:`) provides a way to reference any discovered Grove workspace using a unique identifier. This is the preferred method for cross-project references as it does not rely on fragile relative paths.\n\nThe alias format is based on the workspace's identifier, which often includes its parent ecosystem.\n\n**Alias Formats:**\n-   `@a:\u003cproject-name\u003e`: References a standalone project or the most relevant project with that name.\n-   `@a:\u003cecosystem-name\u003e:\u003cproject-name\u003e`: References a project within an ecosystem.\n-   `@a:\u003cproject-name\u003e:\u003cworktree-name\u003e`: References a specific worktree of a project.\n-   `@a:\u003cproject-name\u003e::\u003cruleset-name\u003e`: Imports a named rule set from another project.\n\n**Example:**\n\n### Managing Repositories with `cx repo`\n\nThe `cx repo` command suite provides tools to inspect and manage the repositories that `cx` clones.\n\n-   **`cx repo list`**: Displays all repositories tracked in the manifest, including their source URL, pinned version, resolved commit, last sync time, and audit status.\n\n-   **`cx repo sync`**: Fetches the latest updates for all tracked repositories and ensures they are checked out to their pinned versions. This is useful for keeping local copies up-to-date.\n\n### Repository Security Audits\n\nBefore including an unfamiliar external repository, it is recommended to perform a security audit. The `cx repo audit` command facilitates an LLM-based analysis to identify potential risks like prompt injection.\n\n**Workflow for `cx repo audit \u003curl\u003e`:**\n\n1.  **Clone**: The repository is cloned to the local cache.\n2.  **Context Refinement**: An interactive TUI (`cx view`) is launched, allowing you to review the repository's files and define the context for the audit by including or excluding files and directories.\n3.  **LLM Analysis**: Once you exit the TUI, `cx` generates the context and sends it to an LLM with a prompt to analyze the code for security vulnerabilities and prompt injection vectors.\n4.  **Review Report**: The LLM's analysis is saved to a markdown file in the cloned repo's `.grove/audits/` directory and opened in your default editor (`$EDITOR`).\n5.  **Approve/Reject**: After reviewing the report, you are prompted to approve or reject the audit.\n6.  **Update Manifest**: Your decision (`passed` or `failed`) is recorded in the `~/.grove/repos.json` manifest. The `cx repo list` command will reflect this status.\n\n**Best Practice**: Always run `cx repo audit` on new third-party repositories before adding rules that reference them. This ensures you understand the content and potential security implications of the code you are including in your context.",
      "code_blocks": [
        "../shared-ui/src/**/*.tsx",
        "https://github.com/mattsolo1/grove-core\n\nhttps://github.com/mattsolo1/grove-core@v0.4.0\n\nhttps://github.com/mattsolo1/grove-core@v0.4.0/pkg/workspace/**",
        "context:\n  default_rules_path: .cx/api.rules",
        "@default: ../shared-lib\n\nsrc/main.go",
        "@a:grove-ecosystem:grove-core/pkg/workspace/**\n\n@a:shared-lib::api"
      ]
    },
    "git-workflows": {
      "title": "Git Workflows",
      "content": "grove-context can generate context rules based on Git history. This mechanism uses `git` commands to identify relevant files and populates the active `.grove/rules` file with their paths, allowing for context generation that is scoped to specific changes.",
      "subsections": [
        {
          "title": "The `from-git` Command",
          "content": "The `cx from-git` command populates the active `.grove/rules` file with a list of files identified by various `git` commands. It overwrites the existing rules file with the generated file list.\n\n### Options\n\n-   `--staged`: Includes files currently in the Git staging area. This corresponds to the output of `git diff --cached --name-only`.\n-   `--branch \u003crange\u003e`: Includes files that differ between two branches or commits. For example, `main..HEAD`. This uses `git diff --name-only \u003crange\u003e`.\n-   `--since \u003cref\u003e`: Includes files modified since a specific date, tag, or commit hash. This uses `git log --since=\u003cref\u003e`.\n-   `--commits \u003cn\u003e`: Includes files modified in the last `\u003cn\u003e` commits. This uses `git log -\u003cn\u003e`."
        },
        {
          "title": "Workflows and Use Cases",
          "content": "The `from-git` command is designed for several common development scenarios.\n\n### Branch Context (Feature Development)\n\nWhen working on a feature branch, you can generate context containing only the files that have changed relative to the main branch.\n\n**Command:**\n\n**Mechanism:**\n1.  `git diff --name-only main..HEAD` is executed to list the files that have changed.\n2.  The active `.grove/rules` file is overwritten with this list of files.\n3.  Subsequent `cx generate` or `gemapi request` commands will use this file list as the context.\n\n### Commit Context (Bug Fixes \u0026 Analysis)\n\nTo analyze changes from recent commits, context can be generated from the last `n` commits.\n\n**Command:**\n\n**Mechanism:**\n1.  `git log -2 --name-only --pretty=format:` is executed to list files modified in the last two commits.\n2.  The file list is deduplicated and written to `.grove/rules`.\n\n### Staged Files (Pre-Commit Review)\n\nBefore committing, you can build a context consisting only of the files currently in the Git staging area. This is useful for reviewing changes or writing a commit message.\n\n**Command:**\n\n**Mechanism:**\n1.  `git diff --cached --name-only` lists the staged files.\n2.  The output is written to `.grove/rules`.\n\n### Code Review Workflows\n\nA reviewer can generate context for a branch they are about to review.\n\n**Command:**\n\n**Mechanism:**\n1.  This compares the current branch (`feature/new-api`) against `main`.\n2.  The resulting file list populates `.grove/rules`, providing the reviewer with the exact context of the changes.\n\n### Merge Conflict Resolution\n\nWhen a merge conflict occurs, you can generate a context of the files that have changed on your current branch to help understand the scope of your changes relative to the merge base.\n\n**Command:**\n\n**Mechanism:**\n1.  This lists all files changed on your current branch that are not in `main`.\n2.  This file list can be used to provide an LLM with the relevant files for assistance in resolving the conflict.",
          "code_blocks": [
            "cx from-git --branch main..HEAD",
            "# Generate context from the last 2 commits\ncx from-git --commits 2",
            "# Stage some files\ngit add path/to/file1.go path/to/file2.go\n\n# Generate context from staged files\ncx from-git --staged",
            "# After checking out the feature branch 'feature/new-api'\ncx from-git --branch main",
            "# After a failed merge from 'main'\ncx from-git --branch main..HEAD"
          ]
        }
      ]
    },
    "loading-rules": {
      "title": "Loading Rules",
      "content": "The `grove-context` tool (`cx`) provides mechanisms for managing different context configurations through named rule sets. This allows users to switch between different views of a codebase depending on the task.",
      "subsections": [
        {
          "title": "Reusable Rule Sets",
          "content": "The primary mechanism for managing context is through rule set files stored in dedicated directories within a project.\n\n-   **`.cx/`**: This directory is for version-controlled, shared rule sets. Files in this directory are intended to be committed to Git and shared across a team.\n-   **`.cx.work/`**: This directory is for local, temporary, or experimental rule sets. It is conventionally added to `.gitignore`.\n\nThis separation allows for different context configurations for different tasks. For example, a project might have rule sets for:\n\n-   Backend development (`.cx/backend.rules`)\n-   Frontend development (`.cx/frontend.rules`)\n-   Documentation generation (`.cx/docs.rules`)\n-   Analyzing a specific feature (`.cx.work/feature-x.rules`)\n\n### Example: Creating Specialized Rule Sets",
          "code_blocks": [
            "# Create a rule set for backend development\ncat \u003e .cx/backend-only.rules \u003c\u003c 'EOF'\n# Backend API code\nsrc/api/**/*.go\nsrc/services/**/*.go\nsrc/models/**/*.go\n\n# Exclude tests\n!**/*_test.go\nEOF\n\n# Create a rule set for frontend development\ncat \u003e .cx/frontend-only.rules \u003c\u003c 'EOF'\n# Frontend UI code\nsrc/ui/**/*.tsx\nsrc/components/**/*.tsx\nsrc/styles/**/*.css\nEOF\n\n# Create a rule set for documentation\ncat \u003e .cx/docs-only.rules \u003c\u003c 'EOF'\ndocs/**/*.md\nREADME.md\n*.md\nEOF"
          ]
        },
        {
          "title": "Managing Active Rule Sets",
          "content": "The context used by `cx` commands is determined by the active rule set. This can be switched to fit the current task.\n\n### Switching the Active Rule Set (`cx rules set`)\n\nThe `cx rules set \u003cname\u003e` command sets the active context to a named rule set from `.cx/` or `.cx.work/`. This creates a read-only link to the specified file.\n\n\n### Creating a Modifiable Working Copy (`cx rules load`)\n\nThe `cx rules load \u003cname\u003e` command copies a named rule set to `.grove/rules`. This creates a local, modifiable working copy. Any changes made to `.grove/rules` will not affect the original named rule set. This is useful for starting from a template and customizing it for a specific task.\n\n### Viewing Rule Sets (`cx rules list`)\n\nThe `cx rules list` command (or simply `cx rules`) displays all available rule sets in `.cx/` and `.cx.work/` and indicates which one is currently active.",
          "code_blocks": [
            "# Switch between the rule sets created above\ncx rules set backend-only\ncx rules set frontend-only\ncx rules set docs-only"
          ]
        },
        {
          "title": "Integration with Other Tools",
          "content": "Other Grove tools can be configured to use specific rule sets for their operations, allowing for task-specific context.\n\n### Grove Flow Integration\n\nIn `grove-flow`, a job can specify its own context by using the `rules_file` field in its frontmatter. This directs the job executor to use that specific rule set instead of the globally active one.",
          "code_blocks": [
            "---\nid: job-backend-refactor\ntitle: Refactor authentication\ntype: oneshot\nrules_file: .cx/auth-only.rules\nworktree: auth-refactor\n---\n\nRefactor the authentication module..."
          ]
        },
        {
          "title": "Importing Rule Sets Across Projects",
          "content": "Rules can be imported from other projects using an alias syntax. This allows for the creation of shared, centralized rule definitions.\n\nThe syntax is `@a:project-alias::ruleset-name`, where `project-alias` is the identifier of another Grove workspace and `ruleset-name` is the name of the rule set file (without the `.rules` extension) in that project's `.cx/` directory.\n\n### Example: Importing Rules",
          "code_blocks": [
            "# In api-server/.grove/rules\n\n# Import a set of standard backend patterns from a template project\n@a:project-template::backend-patterns\n\n# Include this project's specific patterns\nsrc/**/*.go\n!vendor/**\n\n# Import a shared list of common library dependencies\n@a:shared-libs::dependencies"
          ]
        },
        {
          "title": "Resetting to Project Defaults (`cx reset`)",
          "content": "The `cx reset` command overwrites the local `.grove/rules` file with a project-defined default. This is useful for returning to a known-good configuration.\n\n-   The default rule set is specified by the `context.default_rules_path` field in the project's `grove.yml`.\n-   If no default is configured, `cx reset` creates a boilerplate file that includes all non-gitignored files.\n-   The command asks for confirmation before overwriting an existing `.grove/rules` file.\n\n### Example: Team Workflow with Shared and Local Rules\n\n1.  A team defines standard rule sets (e.g., `backend`, `frontend`) in the `.cx/` directory, which is committed to the repository.\n2.  Developers can switch between these standard contexts using `cx rules set backend`.\n3.  An individual developer can create a temporary, experimental rule set in `.cx.work/my-feature.rules`, which is ignored by Git.\n4.  Projects can import team-wide standards from a central repository (e.g., `@a:standards-repo::backend-best`) to ensure consistency."
        }
      ]
    },
    "overview": {
      "title": "Overview",
      "content": "`grove-context` (`cx`) is a command-line tool for assembling file-based context for Large Language Models (LLMs). It is designed to support a **planning ‚Üí execution** workflow, where a comprehensive set of files defining a feature's \"universe\" is used to generate detailed implementation plans from large-context LLMs.\n\nThis approach embraces large context windows (200k-2M+ tokens) for high-level planning, rather than attempting to work around context limits with retrieval-based methods. It acts as the foundational context engine for the Grove ecosystem.\n\n\u003c!-- placeholder for animated gif --\u003e",
      "subsections": [
        {
          "title": "Key Features",
          "content": "-   **Declarative Context Definition:** Define the context \"universe\" using a `.grove/rules` file with gitignore-style patterns and directives. The tool handles the file resolution and assembly.\n\n-   **Workspace-Aware Aliasing:** Reference files across different projects, ecosystems, and worktrees using a consistent alias system (e.g., `@a:ecosystem:repo/path`). This is powered by `grove-core`'s workspace discovery.\n\n-   **Rule Set Management:** Create, manage, and switch between named rule sets for different tasks (e.g., `frontend-only`, `full-stack`, `audit`) using the `cx rules` command.\n\n-   **Interactive Visualization:** Explore context composition with an interactive TUI (`cx view`) that provides a tree view of your project, showing the status of each file (included, excluded, gitignored).\n\n-   **Token \u0026 Cost Analytics:** Analyze token count, file size, and language distribution *before* sending a request to a paid API using the `cx stats` command.\n\n-   **Security Boundaries:** Restricts file access to discovered workspaces and paths explicitly allowed in your `grove.yml` configuration, preventing accidental inclusion of sensitive system files.\n\n-   **Git Integration:** Generate context dynamically from git history, including staged files (`cx from-git --staged`), recent commits, or branch diffs."
        },
        {
          "title": "How It Works",
          "content": "`grove-context` follows a deterministic pipeline to resolve a final list of files:\n\n1.  **Load Rules:** It reads the active rules file (either `.grove/rules` or a named set from `.cx/` specified in state).\n2.  **Expand Directives:** It recursively expands import directives (`@default` for project defaults, `::` for ruleset imports).\n3.  **Resolve Aliases:** It resolves all workspace aliases (`@a:`) to their absolute file paths using `grove-core`'s discovery mechanism.\n4.  **Filter by Gitignore:** It walks the specified file trees, filtering out files and directories matched by `.gitignore` files.\n5.  **Apply Patterns:** It applies all inclusion and exclusion patterns using a \"last match wins\" logic, similar to `.gitignore`.\n6.  **Generate Context:** The final list of files is used to generate a single, concatenated context file (`.grove/context`), separating files into hot (dynamic) and cold (cacheable) sections."
        },
        {
          "title": "Ecosystem Integration",
          "content": "`grove-context` serves as a foundational context engine that enables other tools in the Grove ecosystem.\n\n-   **`grove-core`**: Provides the workspace discovery and identification engine that powers `cx`'s multi-repository alias resolution system.\n-   **`grove-flow`**: Manages per-job context. A job in a `grove-flow` plan can specify a `rules_file` in its frontmatter, which `cx` uses to generate a focused context for that specific task.\n-   **`grove-gemini`**: The `gemapi request` command automatically uses `cx` to generate context from the active `.grove/rules` file, handling the separation of hot and cold context for efficient caching with the Gemini API.\n-   **`grove-nvim`**: Offers editor integration for `.grove/rules` files, providing real-time token counts as virtual text, file previews for rules, and commands to manage context directly from Neovim."
        },
        {
          "title": "Installation",
          "content": "Install via the Grove meta-CLI:\n\nVerify installation:\n\nRequires the `grove` meta-CLI. See the [Grove Installation Guide](https://github.com/mattsolo1/grove-meta/blob/main/docs/02-installation.md) if you don't have it installed.",
          "code_blocks": [
            "grove install context",
            "cx version"
          ]
        }
      ],
      "code_blocks": [
        ".grove/rules       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n(patterns,    ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ grove-context   ‚îÇ ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ LLM API   ‚îÇ\n aliases)          ‚îÇ (cx)            ‚îÇ      ‚îÇ (Gemini,  ‚îÇ\n                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ Claude)   ‚îÇ\nProject Files                             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n(multi-repo)       ‚óÑ‚îÄ‚îÄ‚îÄ (reads files)           ‚îÇ\n                                                ‚ñº\n                                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                                         ‚îÇ Detailed  ‚îÇ\n                                         ‚îÇ Plan      ‚îÇ\n                                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
      ]
    },
    "rules-and-patterns": {
      "title": "Rules \u0026 Patterns",
      "content": "This document describes the syntax and usage of `grove-context` rules files for defining the context provided to LLMs.\n\n### Rules File Basics\n\nThe context for a project is defined by a rules file. This file lists patterns that determine which files are included or excluded.\n\n-   **Location**: The primary rules file is located at `.grove/rules` in the project root.\n-   **Format**: A plain text file with one pattern per line.\n-   **Comments**: Lines beginning with `#` are ignored.\n-   **Syntax**: The syntax is based on `.gitignore` patterns.\n-   **Hot vs. Cold Context**: A `---` separator divides the file into two sections. Patterns *before* the separator define \"hot context\" (included in every request). Patterns *after* define \"cold context\" (used for caching with supported models like Gemini).\n\n### Pattern Syntax Reference\n\nPatterns specify which files to include or exclude. The system uses \"last match wins\" logic.\n\n| Pattern                  | Description                                                                                              |\n| ------------------------ | -------------------------------------------------------------------------------------------------------- |\n| `*.go`                   | Matches files with a `.go` extension in the current directory.                                           |\n| `src/**/*.ts`            | Recursively matches all files with a `.ts` extension in the `src` directory and its subdirectories.      |\n| `!node_modules/`         | Excludes the `node_modules` directory.                                                                   |\n| `src/`                   | Matches all files within the `src` directory.                                                            |\n| `/absolute/path/to/file` | Matches an exact absolute file path.                                                                     |\n| `../sibling-project/**`  | Matches all files in an adjacent directory.                                                              |\n| `@a:project-name`        | An **alias** referencing a discovered workspace. Expands to include all files in that project.           |\n| `@a:project/src/**.go`   | Combines an alias with a glob pattern to include specific files from another project.                    |\n| `@a:eco:repo`            | An alias referencing a sub-project within an ecosystem.                                                  |\n| `@a:repo:worktree`       | An alias referencing a specific worktree of a project.                                                   |\n| `@a:project::ruleset`    | Imports a named rule set from another project.                                                           |\n\n### Alias Resolution System\n\nAliases provide a stable way to reference other projects without using relative or absolute paths.\n\n-   **Syntax**: `@a:name` (short form) or `@alias:name` (long form).\n-   **Discovery**: `grove-context` uses `grove-core` to discover all workspaces (projects, ecosystems, worktrees) defined in your configuration. Each discovered entity is given a unique identifier that can be used as an alias.\n-   **Resolution**:\n    -   **1-part (`@a:project-name`):** Resolves to a project. If multiple projects have the same name, it prioritizes siblings within the same ecosystem or top-level projects.\n    -   **2-part (`@a:ecosystem:repo` or `@a:repo:worktree`):** Resolves a sub-project within an ecosystem, or a worktree of a specific repository.\n    -   **3-part (`@a:ecosystem:repo:worktree`):** Resolves a specific worktree of a sub-project within an ecosystem.\n-   **Viewing Aliases**: Use `cx workspace list` to see all available workspaces and their identifiers, which can be used as aliases.\n\n### Include/Exclude Logic\n\nThe context is built by applying rules in order:\n\n1.  **`.gitignore` First**: All files ignored by `.gitignore` are excluded by default. They cannot be re-included.\n2.  **Last Match Wins**: For files not ignored by Git, the last pattern in the rules file that matches the file path determines its inclusion or exclusion.\n    -   If the last matching rule starts with `!`, the file is **excluded**.\n    -   If the last matching rule does not start with `!`, the file is **included**.\n\n### Pattern Writing Strategies\n\n-   **Start Broad, Exclude Specifics**: A common approach is to start with a broad inclusion pattern like `*` or `**/*`, and then add `!` patterns to exclude unwanted files and directories.\n-   **Organize Multi-Repo Contexts**:\n    -   **Relative Paths**: Use relative paths for projects in a known directory structure (e.g., `../api-service/**`).\n    -   **Aliases**: Use aliases for a more robust way to reference projects regardless of their location on disk (e.g., `@a:api-service/**`). This is the recommended approach for team consistency.\n-   **Comment Your Rules**: Use `#` to add comments explaining why certain files are included or excluded, especially for complex patterns.\n\n### Reusable Rule Sets\n\nFor different tasks, you often need different contexts. `grove-context` supports creating and switching between named rule sets.\n\n-   **Location**:\n    -   `.cx/`: For shared, version-controlled rule sets (e.g., `.cx/backend.rules`).\n    -   `.cx.work/`: For personal, temporary, or experimental rule sets (this directory is gitignored).\n-   **Why Create Rule Sets?**\n    -   **Role-based**: `backend-only.rules`, `frontend-only.rules`, `docs-only.rules`.\n    -   **Feature-based**: `auth-module.rules`, `billing-api.rules`.\n    -   **Task-based**: `debugging.rules` (include logs), `refactoring.rules` (include tests).\n-   **Commands**:\n    -   `cx rules`: Interactively select the active rule set.\n    -   `cx rules set \u003cname\u003e`: Set the active rule set.\n    -   `cx rules save \u003cname\u003e`: Save the current `.grove/rules` to a named set in `.cx/`. Use `--work` to save to `.cx.work/`.\n    -   `cx rules load \u003cname\u003e`: Copy a named rule set to `.grove/rules` to use as a modifiable working copy.\n-   **Importing Rule Sets**: You can import rules from another project's named rule set using the `::` syntax. This promotes consistency across a large ecosystem.\n    -   `@a:shared-patterns::go-backend` imports the `go-backend.rules` set from the `shared-patterns` project.\n\n### Editing Rules\n\n-   **`cx edit`**: Run `cx edit` in your terminal to open the active rules file in your default `$EDITOR`.\n-   **Neovim Integration**: The `grove-nvim` plugin provides real-time feedback directly in the editor:\n    -   Virtual text shows the token and file count for each rule.\n    -   Syntax highlighting for rules and directives.\n    -   `gf` keymap to jump to the file or directory referenced by a rule.\n\n---\n\n### Examples\n\n#### Go Project\n\n\n#### JavaScript/TypeScript Project\n\n\n#### Multi-Repo Workspace (Relative Paths)\n\n\n#### Multi-Repo Workspace (Aliases)\n\n\n#### Specialized Rule Set (`.cx/backend-only.rules`)\n\n\n#### Importing a Rule Set\n\n\n### Best Practices\n\n-   **Keep Patterns Simple**: Prefer simple, readable patterns over complex ones.\n-   **Version Control Rules**: Store shared rule sets in the `.cx/` directory and commit them to Git.\n-   **Use `.cx.work/` for Personal Rules**: Use the gitignored `.cx.work/` directory for local experiments or personal workflows.\n-   **Use Descriptive Names**: Name your rule sets clearly (e.g., `api-only`, `refactor-auth-service`).\n-   **Import for Consistency**: Create a central project with standard rule sets (`go-defaults`, `ts-react-app`) and import them using `@a:project::ruleset` to enforce consistency.\n-   **Switch Contexts Frequently**: Use `cx rules` to switch between rule sets based on your current task. This keeps the context small and relevant, improving LLM accuracy and reducing cost.",
      "code_blocks": [
        "\n*.go\ngo.mod\ngo.sum\nMakefile\n\n!*_test.go\n!vendor/",
        "\nsrc/**/*.ts\nsrc/**/*.tsx\n\n!*.spec.ts\n!*.test.ts\n!node_modules/\n!dist/\n!build/",
        "\n../api/**\n../frontend/**\n\n!**/*_test.go\n!**/*.spec.ts",
        "\n@a:grove-core/**/*.go\n@a:grove-nvim/lua/**/*.lua\n\n!**/*_test.go",
        "\n\n*.go\ngo.mod\ngo.sum\n\n!*_test.go\n!frontend/\n!docs/",
        "\n@a:shared-infra::go-backend\n\nsrc/main.go\nconfig.yml"
      ]
    }
  }
}