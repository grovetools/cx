// File: grove-context/tests/e2e/scenarios_tui.go
package main

import (
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/mattsolo1/grove-tend/pkg/fs"
	"github.com/mattsolo1/grove-tend/pkg/harness"
	"github.com/mattsolo1/grove-tend/pkg/tui"
)

// TUIViewScenario tests the interactive `cx view` TUI using the enhanced APIs.
func TUIViewScenario() *harness.Scenario {
	return &harness.Scenario{
		Name:        "cx-view-tui-test",
		Description: "Tests the interactive `cx view` TUI using robust navigation and timing APIs.",
		Tags:        []string{"cx", "tui", "view", "interactive"},
		Steps: []harness.Step{
			harness.NewStep("Clean up existing tmux sessions", func(ctx *harness.Context) error {
				// Clean up any existing tend test sessions to avoid conflicts
				// This helps ensure a clean test environment
				if err := CleanupExistingTestSessions(); err != nil {
					// Non-fatal: just log the warning
					fmt.Printf("   ‚ö†Ô∏è  Warning: Could not clean existing sessions: %v\n", err)
				}
				fmt.Println("   üßπ Session cleanup complete")
				return nil
			}),
			harness.NewStep("Setup project for TUI view", func(ctx *harness.Context) error {
				// Create a predictable file structure for the TUI to display.
				if err := fs.WriteString(filepath.Join(ctx.RootDir, "main.go"), "package main // in hot context"); err != nil {
					return err
				}
				// Create a specific readme file that should be safe to add
				if err := fs.WriteString(filepath.Join(ctx.RootDir, "PROJECT_README.md"), "# Project README"); err != nil {
					return err
				}
				if err := fs.WriteString(filepath.Join(ctx.RootDir, "utils_test.go"), "package main // excluded"); err != nil {
					return err
				}
				// Create a docs directory for testing directory expansion
				if err := fs.CreateDir(filepath.Join(ctx.RootDir, "docs")); err != nil {
					return err
				}
				if err := fs.WriteString(filepath.Join(ctx.RootDir, "docs", "api.md"), "# API Documentation"); err != nil {
					return err
				}
				// Create rules that will put main.go in hot context, exclude the test, and leave PROJECT_README.md omitted.
				rules := "**/*.go\n!**/*_test.go"
				return fs.WriteString(filepath.Join(ctx.RootDir, ".grove", "rules"), rules)
			}),
			harness.NewStep("Launch 'cx view' in tmux", func(ctx *harness.Context) error {
				cxBinary, err := FindProjectBinary()
				if err != nil {
					return err
				}

				// Start the TUI in an isolated tmux session. The harness manages its lifecycle.
				session, err := ctx.StartTUI(cxBinary, "view")
				if err != nil {
					return fmt.Errorf("failed to start 'cx view' TUI: %w", err)
				}

				// Print session info for debugging - useful when running with -d flag
				// Note: session name is dynamically generated by the harness
				fmt.Println("   üì∫ TUI session started (use -d flag to debug interactively)")

				// Store the session handle in the context to interact with it in later steps.
				ctx.Set("view_session", session)
				return nil
			}),
			harness.NewStep("Wait for TUI to stabilize", func(ctx *harness.Context) error {
				session := ctx.Get("view_session").(*tui.Session)
				
				// NEW: Use WaitForUIStable instead of WaitForText + time.Sleep
				// This is more reliable as it waits for the UI to stop changing
				if err := session.WaitForUIStable(5*time.Second, 100*time.Millisecond, 300*time.Millisecond); err != nil {
					return fmt.Errorf("TUI did not stabilize: %w", err)
				}
				
				// Verify the header is present
				if err := session.WaitForText("Grove Context Visualization", 2*time.Second); err != nil {
					return fmt.Errorf("TUI header not found: %w", err)
				}
				
				return nil
			}),
			harness.NewStep("Verify status indicators", func(ctx *harness.Context) error {
				session := ctx.Get("view_session").(*tui.Session)
				
				// Capture screen to verify status indicators
				content, err := session.Capture()
				if err != nil {
					return fmt.Errorf("failed to capture screen: %w", err)
				}
				
				// Verify main.go has hot context indicator (‚úì)
				if !strings.Contains(content, "‚úì") || !strings.Contains(content, "main.go") {
					return fmt.Errorf("expected main.go to show hot context indicator (‚úì)")
				}
				
				// Verify utils_test.go has excluded indicator (üö´)
				if !strings.Contains(content, "üö´") || !strings.Contains(content, "utils_test.go") {
					return fmt.Errorf("expected utils_test.go to show excluded indicator (üö´)")
				}
				
				// Verify PROJECT_README.md has no indicator (omitted file)
				// It should appear without ‚úì or üö´
				if strings.Contains(content, "‚úì PROJECT_README.md") || strings.Contains(content, "üö´ PROJECT_README.md") {
					return fmt.Errorf("PROJECT_README.md should not have any status indicator")
				}
				
				fmt.Println("   ‚úì Status indicators verified")
				return nil
			}),
			harness.NewStep("Test additional key bindings", func(ctx *harness.Context) error {
				session := ctx.Get("view_session").(*tui.Session)
				
				// Test pressing 'c' for cold context toggle (should do nothing on PROJECT_README.md)
				if err := session.NavigateToText("PROJECT_README.md"); err != nil {
					return fmt.Errorf("failed to navigate to PROJECT_README.md: %w", err)
				}
				
				if err := session.SendKeys("c"); err != nil {
					return fmt.Errorf("failed to send 'c' key: %w", err)
				}
				
				// Small wait for any potential action
				time.Sleep(300 * time.Millisecond)
				
				// The file should still not have any indicator (remains omitted)
				content, err := session.Capture()
				if err != nil {
					return fmt.Errorf("failed to capture after 'c' key: %w", err)
				}
				
				if strings.Contains(content, "‚úì PROJECT_README.md") || strings.Contains(content, "‚ùÑÔ∏è PROJECT_README.md") {
					return fmt.Errorf("PROJECT_README.md should remain omitted after 'c' key")
				}
				
				fmt.Println("   ‚úì Additional key bindings tested")
				return nil
			}),
			harness.NewStep("Verify statistics panel", func(ctx *harness.Context) error {
				session := ctx.Get("view_session").(*tui.Session)
				
				content, err := session.Capture()
				if err != nil {
					return fmt.Errorf("failed to capture screen: %w", err)
				}
				
				// Verify statistics are shown
				if !strings.Contains(content, "Context Statistics") {
					return fmt.Errorf("statistics panel not found")
				}
				
				// Verify hot context count (should show 1 file - main.go)
				if !strings.Contains(content, "Hot:") || !strings.Contains(content, "1 files") {
					return fmt.Errorf("expected hot context to show 1 file")
				}
				
				// Verify cold context count (should be 0)
				if !strings.Contains(content, "Cold:") || !strings.Contains(content, "0 files") {
					return fmt.Errorf("expected cold context to show 0 files")
				}
				
				fmt.Println("   ‚úì Statistics panel verified")
				return nil
			}),
			harness.NewStep("Test help system", func(ctx *harness.Context) error {
				session := ctx.Get("view_session").(*tui.Session)
				
				// Press '?' to open help
				if err := session.SendKeys("?"); err != nil {
					return fmt.Errorf("failed to open help: %w", err)
				}
				
				// Wait for any help-related text to appear
				time.Sleep(500 * time.Millisecond)
				
				content, err := session.Capture()
				if err != nil {
					return fmt.Errorf("failed to capture help screen: %w", err)
				}
				
				// Just verify that the screen changed and shows help-related content
				// Being less strict about exact content to avoid brittleness
				if !strings.Contains(content, "help") && !strings.Contains(content, "Help") && 
				   !strings.Contains(content, "Navigation") && !strings.Contains(content, "Actions") {
					// Help might not have opened, try to close anyway
					session.SendKeys("?")
					return fmt.Errorf("help content not detected")
				}
				
				// Close help
				if err := session.SendKeys("?"); err != nil {
					return fmt.Errorf("failed to close help: %w", err)
				}
				
				// Small wait for transition
				time.Sleep(300 * time.Millisecond)
				
				fmt.Println("   ‚úì Help system tested")
				return nil
			}),
			harness.NewStep("Test Tab key for view switching", func(ctx *harness.Context) error {
				session := ctx.Get("view_session").(*tui.Session)
				
				// Press Tab to switch to repository view
				if err := session.SendKeys("tab"); err != nil {
					return fmt.Errorf("failed to send Tab key: %w", err)
				}
				
				// Wait for view switch
				if err := session.WaitForUIStable(2*time.Second, 100*time.Millisecond, 200*time.Millisecond); err != nil {
					fmt.Printf("   UI stability warning after Tab: %v\n", err)
				}
				
				// Capture screen to verify we're in repository view
				content, err := session.Capture()
				if err != nil {
					return fmt.Errorf("failed to capture after Tab: %w", err)
				}
				
				// Check for repository view indicators
				// Repository view typically shows "Repository Selection" or different content
				if strings.Contains(content, "Repository") || strings.Contains(content, "grove-") ||
				   !strings.Contains(content, "PROJECT_README.md") {
					fmt.Println("   ‚úì Switched to repository view")
				} else {
					// Still seems to be in tree view, that's okay - might not have repos
					fmt.Println("   ‚úì Tab key processed (stayed in tree view - no repos)")
				}
				
				// Press Tab again to switch back
				if err := session.SendKeys("tab"); err != nil {
					return fmt.Errorf("failed to send second Tab key: %w", err)
				}
				
				// Small wait for view switch
				time.Sleep(300 * time.Millisecond)
				
				// Verify we're back in tree view
				content, err = session.Capture()
				if err != nil {
					return fmt.Errorf("failed to capture after second Tab: %w", err)
				}
				
				// Should see our files again
				if strings.Contains(content, "main.go") || strings.Contains(content, "PROJECT_README.md") {
					fmt.Println("   ‚úì Switched back to tree view")
					return nil
				}
				
				// If we don't see files, we might still be in repo view or help
				// This is not a failure - just indicates the Tab behavior might be different
				fmt.Println("   ‚úì Tab key navigation tested")
				return nil
			}),
			harness.NewStep("Navigate to target file for safety test", func(ctx *harness.Context) error {
				session := ctx.Get("view_session").(*tui.Session)

				// Navigate directly to PROJECT_README.md
				if err := session.NavigateToText("PROJECT_README.md"); err != nil {
					return fmt.Errorf("failed to navigate to PROJECT_README.md: %w", err)
				}
				
				// Verify cursor position
				curRow, curCol, err := session.GetCursorPosition()
				if err != nil {
					return fmt.Errorf("failed to get cursor position: %w", err)
				}
				fmt.Printf("   Cursor positioned at row %d, col %d\n", curRow, curCol)
				
				return nil
			}),
			harness.NewStep("Trigger safety validation", func(ctx *harness.Context) error {
				session := ctx.Get("view_session").(*tui.Session)

				// Simulate user pressing 'h' to attempt adding the selected file to hot context.
				// This should trigger safety validation and show an error.
				if err := session.SendKeys("h"); err != nil {
					return fmt.Errorf("failed to send 'h' key: %w", err)
				}
				
				// NEW: Use WaitForUIStable instead of time.Sleep
				// Wait for the UI to process the action and show the error
				if err := session.WaitForUIStable(3*time.Second, 100*time.Millisecond, 200*time.Millisecond); err != nil {
					// Non-fatal: UI might not stabilize due to error message
					fmt.Printf("   UI stability warning: %v\n", err)
				}
				
				return nil
			}),
			harness.NewStep("Verify safety validation triggered", func(ctx *harness.Context) error {
				session := ctx.Get("view_session").(*tui.Session)

				// Capture the entire screen content to verify the safety validation.
				content, err := session.Capture()
				if err != nil {
					return fmt.Errorf("failed to capture TUI screen: %w", err)
				}

				// Verify that safety validation was triggered as expected
				if strings.Contains(content, "safety validation failed") && 
				   strings.Contains(content, "PROJECT_README.md") &&
				   strings.Contains(content, "would include system directory") {
					// Success - only log a simple confirmation, no screen dump
					fmt.Println("   ‚úì Safety validation correctly prevented unsafe rule")
					return nil
				}

				// Only show the full TUI capture if something went wrong
				// If the file was somehow added (unexpected), that would be an error
				if strings.Contains(content, "‚úì PROJECT_README.md") {
					ctx.ShowCommandOutput("UNEXPECTED TUI State", content, "")
					return fmt.Errorf("unexpected: PROJECT_README.md was added despite safety concerns")
				}

				// Show capture when we can't find expected error
				ctx.ShowCommandOutput("TUI State (Expected Safety Error Not Found)", content, "")
				return fmt.Errorf("expected safety validation error but did not find it")
			}),
			harness.NewStep("Quit the TUI", func(ctx *harness.Context) error {
				session := ctx.Get("view_session").(*tui.Session)
				// Send 'q' to gracefully exit the application.
				if err := session.SendKeys("q"); err != nil {
					return fmt.Errorf("failed to send 'q' key: %w", err)
				}
				
				// NEW: Wait for UI to close cleanly instead of fixed sleep
				// Allow time for graceful shutdown
				time.Sleep(200 * time.Millisecond)
				
				return nil
			}),
		},
	}
}